(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{1952:function(a,t,s){a.exports=s.p+"assets/img/img007.9ad7afe5.png"},1953:function(a,t,s){a.exports=s.p+"assets/img/img008.ea600562.png"},1954:function(a,t,s){a.exports=s.p+"assets/img/img009.a0b70cb3.png"},1955:function(a,t,s){a.exports=s.p+"assets/img/img010.5af189f7.png"},2484:function(a,t,s){"use strict";s.r(t);var _=s(21),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"第四节-aop术语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四节-aop术语"}},[a._v("#")]),a._v(" 第四节 AOP术语")]),a._v(" "),_("h2",{attrs:{id:"_1、横切关注点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、横切关注点"}},[a._v("#")]),a._v(" 1、横切关注点")]),a._v(" "),_("p",[a._v("从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。")]),a._v(" "),_("p",[a._v("这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。")]),a._v(" "),_("p",[_("img",{staticClass:"lazy",attrs:{alt:"./images","data-src":s(1952),loading:"lazy"}})]),a._v(" "),_("h2",{attrs:{id:"_2、通知-记住"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、通知-记住"}},[a._v("#")]),a._v(" 2、通知[记住]")]),a._v(" "),_("p",[a._v("每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。")]),a._v(" "),_("ul",[_("li",[a._v("前置通知：在被代理的目标方法前执行")]),a._v(" "),_("li",[a._v("返回通知：在被代理的目标方法寿终正寝）")]),a._v(" "),_("li",[a._v("异常通知：在被代理的目标方法死于非命）")]),a._v(" "),_("li",[a._v("后置通知：在被代理的目标方法盖棺定论）")]),a._v(" "),_("li",[a._v("环绕通知：使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置")])]),a._v(" "),_("p",[_("img",{staticClass:"lazy",attrs:{alt:"./images","data-src":s(1953),loading:"lazy"}})]),a._v(" "),_("h2",{attrs:{id:"_3、切面-记住"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、切面-记住"}},[a._v("#")]),a._v(" 3、切面[记住]")]),a._v(" "),_("p",[a._v("封装通知方法的类。")]),a._v(" "),_("p",[_("img",{staticClass:"lazy",attrs:{alt:"./images","data-src":s(1954),loading:"lazy"}})]),a._v(" "),_("h2",{attrs:{id:"_4、目标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、目标"}},[a._v("#")]),a._v(" 4、目标")]),a._v(" "),_("p",[a._v("被代理的目标对象。")]),a._v(" "),_("h2",{attrs:{id:"_5、代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、代理"}},[a._v("#")]),a._v(" 5、代理")]),a._v(" "),_("p",[a._v("向目标对象应用通知之后创建的代理对象。")]),a._v(" "),_("h2",{attrs:{id:"_6、连接点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6、连接点"}},[a._v("#")]),a._v(" 6、连接点")]),a._v(" "),_("p",[a._v("这也是一个纯逻辑概念，不是语法定义的。")]),a._v(" "),_("p",[a._v("把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。")]),a._v(" "),_("p",[_("img",{staticClass:"lazy",attrs:{alt:"./images","data-src":s(1955),loading:"lazy"}})]),a._v(" "),_("h2",{attrs:{id:"_7、切入点-记住"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7、切入点-记住"}},[a._v("#")]),a._v(" 7、切入点[记住]")]),a._v(" "),_("p",[a._v("定位连接点的方式。")]),a._v(" "),_("p",[a._v("每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。")]),a._v(" "),_("p",[a._v("如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。")]),a._v(" "),_("p",[a._v("Spring 的 AOP 技术可以通过切入点定位到特定的连接点。")]),a._v(" "),_("p",[a._v("切点通过 org.springframework.aop. Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。")])])}),[],!1,null,null,null);t.default=r.exports}}]);