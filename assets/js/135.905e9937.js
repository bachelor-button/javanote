(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{2368:function(v,_,t){"use strict";t.r(_);var a=t(21),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"第四节-垃圾回收器-了解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第四节-垃圾回收器-了解"}},[v._v("#")]),v._v(" 第四节 垃圾回收器 [了解]")]),v._v(" "),a("h2",{attrs:{id:"_1、串行垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、串行垃圾回收器"}},[v._v("#")]),v._v(" 1、串行垃圾回收器")]),v._v(" "),a("p",[v._v("新生代串行回收器 SerialGC：采用复制算法实现，单线程垃圾回收，独占式垃圾回收器")]),v._v(" "),a("p",[v._v("老年代串行回收器 SerialOldGC：采用标记压缩算法，单线程独占式垃圾回收器")]),v._v(" "),a("h2",{attrs:{id:"_2、并行垃圾回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、并行垃圾回收器"}},[v._v("#")]),v._v(" 2、并行垃圾回收器")]),v._v(" "),a("p",[v._v("新生代 parNew 回收器：采用复制算法实现，多线程回收器，独占式垃圾回收器。")]),v._v(" "),a("p",[v._v("新生代 ParallelScavengeGC 回收器：采用复制算法多线程独占式回收器")]),v._v(" "),a("p",[v._v("老年代 ParallelOldGC 回收器: 采用标记压缩算法，多线程独占式回收器")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("CMS回收器")]),v._v(" "),a("p",[v._v("CMS全称 (Concurrent Mark Sweep)，是一款并发的、使用标记-清除算法的垃圾回收器。对CPU资源非常敏感。"),a("br")]),v._v(" "),a("p",[v._v("启用CMS回收器参数 ：-XX:+UseConcMarkSweepGC。"),a("br")]),v._v(" "),a("p",[v._v("使用场景：GC过程短暂停顿，适合对时延要求较高的服务，用户线程不允许长时间的停顿。"),a("br")]),v._v(" "),a("p",[v._v("优点：最短回收停顿时间为目标的收集器。并发收集，低停顿。"),a("br")]),v._v(" "),a("p",[v._v("缺点：服务长时间运行，造成严重的内存碎片化。算法实现比较复杂。")])]),v._v(" "),a("li",[a("p",[v._v("G1回收器")]),v._v(" "),a("p",[v._v("G1(Garbage-First)是一款面向服务端应用的并发垃圾回收器, 主要目标用于配备多颗CPU的服务器治理大内存。是JDK1.7提供的一个新收集器，是当今收集器技术发展的最前沿成果之一。"),a("br")]),v._v(" "),a("p",[v._v("G1计划是并发标记-清除收集器的长期替代品。"),a("br")]),v._v(" "),a("p",[v._v("启用G1收集器参数：-XX:+UseG1GC启用G1收集器。"),a("br")]),v._v(" "),a("p",[v._v("G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了, 它们都是一部分Region(不需要连续)的集合。")]),v._v(" "),a("p",[a("img",{staticClass:"lazy",attrs:{alt:"images","data-src":t(535),loading:"lazy"}})]),v._v(" "),a("p",[v._v("每块区域既有可能属于Old区、也有可能是Young区，因此不需要一次就对整个老年代/新生代回收。而是当线程并发寻找可回收的对象时，有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程，但可以用相对较少的时间优先回收垃圾较多的Region(这也是G1命名的来源)。这种方式保证了G1可以在有限的时间内获取尽可能高的收集效率。"),a("br")]),v._v(" "),a("p",[v._v("特点：")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("一整块堆内存被分成多个独立的区域Regions")])]),v._v(" "),a("li",[a("p",[v._v("存活对象被拷贝到新的Survivor区")])]),v._v(" "),a("li",[a("p",[v._v("新生代内存由一组不连续的堆heap区组成，使得可以动态调整各个区域")])]),v._v(" "),a("li",[a("p",[v._v("多线程并发GC")])]),v._v(" "),a("li",[a("p",[v._v("young GC会有STW（Stop the world）事件")])])])])]),v._v(" "),a("h2",{attrs:{id:"_3、垃圾回收器对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、垃圾回收器对比"}},[v._v("#")]),v._v(" 3、垃圾回收器对比")]),v._v(" "),a("h3",{attrs:{id:"_1新生代回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1新生代回收器"}},[v._v("#")]),v._v(" ①新生代回收器")]),v._v(" "),a("table",[a("thead",[a("tr",[a("th",[v._v("名称")]),v._v(" "),a("th",[v._v("串行/并行/并发")]),v._v(" "),a("th",[v._v("回收算法")]),v._v(" "),a("th",[v._v("适用场景")]),v._v(" "),a("th",[v._v("可以与CMS配合")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[v._v("SerialGC")]),v._v(" "),a("td",[v._v("串行")]),v._v(" "),a("td",[v._v("复制")]),v._v(" "),a("td",[v._v("单CPU")]),v._v(" "),a("td",[v._v("是")])]),v._v(" "),a("tr",[a("td",[v._v("ParNewGC")]),v._v(" "),a("td",[v._v("并行")]),v._v(" "),a("td",[v._v("复制")]),v._v(" "),a("td",[v._v("多CPU")]),v._v(" "),a("td",[v._v("是")])]),v._v(" "),a("tr",[a("td",[v._v("ParallelScavengeGC")]),v._v(" "),a("td",[v._v("并行")]),v._v(" "),a("td",[v._v("复制")]),v._v(" "),a("td",[v._v("多CPU且关注吞吐量")]),v._v(" "),a("td",[v._v("否")])])])]),v._v(" "),a("h3",{attrs:{id:"_2老年代回收器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2老年代回收器"}},[v._v("#")]),v._v(" ②老年代回收器")]),v._v(" "),a("table",[a("thead",[a("tr",[a("th",[v._v("名称")]),v._v(" "),a("th",[v._v("串行/并行/并发")]),v._v(" "),a("th",[v._v("回收算法")]),v._v(" "),a("th",[v._v("适用场景")])])]),v._v(" "),a("tbody",[a("tr",[a("td",[v._v("SerialOldGC")]),v._v(" "),a("td",[v._v("串行")]),v._v(" "),a("td",[v._v("标记压缩")]),v._v(" "),a("td",[v._v("单CPU")])]),v._v(" "),a("tr",[a("td",[v._v("ParNewOldGC")]),v._v(" "),a("td",[v._v("并行")]),v._v(" "),a("td",[v._v("标记压缩")]),v._v(" "),a("td",[v._v("多CPU")])]),v._v(" "),a("tr",[a("td",[v._v("CMS")]),v._v(" "),a("td",[v._v("并发，几乎不会暂停用户线程")]),v._v(" "),a("td",[v._v("标记清除")]),v._v(" "),a("td",[v._v("多CPU且与用户线程共存")])])])]),v._v(" "),a("p",[a("RouterLink",{attrs:{to:"/note/advance/jvm/chapter08/verse04.html"}},[v._v("上一节")]),v._v(" "),a("RouterLink",{attrs:{to:"/note/advance/jvm/chapter08/index.html"}},[v._v("回目录")])],1)])}),[],!1,null,null,null);_.default=r.exports},535:function(v,_,t){v.exports=t.p+"assets/img/img031.d23011be.png"}}]);