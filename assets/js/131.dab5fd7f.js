(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{2350:function(t,a,s){"use strict";s.r(a);var e=s(21),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"第三章-总体机制中不重要的部分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三章-总体机制中不重要的部分"}},[t._v("#")]),t._v(" 第三章 总体机制中不重要的部分")]),t._v(" "),e("h2",{attrs:{id:"_1、本地方法栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、本地方法栈"}},[t._v("#")]),t._v(" 1、本地方法栈")]),t._v(" "),e("p",[t._v("专门负责在本地方法运行时，提供栈空间，存放本地方法每一次执行时创建的栈帧。")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("native")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h2",{attrs:{id:"_2、程序计数器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、程序计数器"}},[t._v("#")]),t._v(" 2、程序计数器")]),t._v(" "),e("p",[t._v("也叫PC寄存器（"),e("span",{staticStyle:{color:"blue","font-weight":"bold"}},[t._v("P")]),t._v("rogram "),e("span",{staticStyle:{color:"blue","font-weight":"bold"}},[t._v("C")]),t._v("ounter Register）。用于保存程序执行过程中，下一条即将执行的指令的地址。也就是说能够保存程序当前已经执行到的位置。")]),t._v(" "),e("h2",{attrs:{id:"_3、执行引擎"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、执行引擎"}},[t._v("#")]),t._v(" 3、执行引擎")]),t._v(" "),e("p",[t._v("作用：用于执行字节码文件中的指令。")]),t._v(" "),e("p",[t._v("执行指令的具体技术：")]),t._v(" "),e("ul",[e("li",[t._v("解释执行：第一代JVM。")]),t._v(" "),e("li",[t._v("即时编译：JIT，第二代JVM。")]),t._v(" "),e("li",[t._v("自适应优化：目前Sun的Hotspot JVM采用这种技术。吸取了第一代JVM和第二代JVM的经验，在一开始的时候对代码进行解释执行， 同时使用一个后台线程监控代码的执行。如果一段代码经常被调用，那么就对这段代码进行编译，编译为本地代码，并进行执行优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行。")]),t._v(" "),e("li",[t._v("芯片级直接执行：内嵌在芯片上，用本地方法执行Java字节码。")])]),t._v(" "),e("h2",{attrs:{id:"_4、直接内存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、直接内存"}},[t._v("#")]),t._v(" 4、直接内存")]),t._v(" "),e("p",[e("img",{staticClass:"lazy",attrs:{alt:"images","data-src":s(505),loading:"lazy"}})]),t._v(" "),e("h3",{attrs:{id:"_1作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1作用"}},[t._v("#")]),t._v(" ①作用")]),t._v(" "),e("p",[t._v("提高特定场景下性能。")]),t._v(" "),e("h3",{attrs:{id:"_2应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2应用场景"}},[t._v("#")]),t._v(" ②应用场景")]),t._v(" "),e("p",[t._v("直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。\n配置虚拟机参数时，不要忽略直接内存防止出现 OutOfMemoryError 异常。")]),t._v(" "),e("h3",{attrs:{id:"_3直接内存-堆外内存-与堆内存比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3直接内存-堆外内存-与堆内存比较"}},[t._v("#")]),t._v(" ③直接内存（堆外内存）与堆内存比较")]),t._v(" "),e("p",[t._v("直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。直接内存 I/O 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。")]),t._v(" "),e("p",[e("RouterLink",{attrs:{to:"/note/advance/jvm/chapter02/index.html"}},[t._v("上一章")]),t._v(" "),e("RouterLink",{attrs:{to:"/note/advance/jvm/index.html"}},[t._v("回目录")]),t._v(" "),e("RouterLink",{attrs:{to:"/note/advance/jvm/chapter04/index.html"}},[t._v("下一章")])],1)])}),[],!1,null,null,null);a.default=r.exports},505:function(t,a,s){t.exports=s.p+"assets/img/img003.4f1719e1.png"}}]);